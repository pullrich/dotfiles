# ---------------------------   Functions    -----------------------------------

# https://github.com/rwxrob/dot/blob/main/.bashrc
_pathclean() {
 local arg
 for arg in "$@"; do
    # middle
    PATH=${PATH//:${arg}:/:}
    # front
    PATH=${PATH/#${arg}:/}
    # end
    PATH=${PATH/%:${arg}/}
    export PATH
 done

}

pathappend() {
  local arg
  for arg in "$@"; do
    _pathclean "${arg}"
    test -d "${arg}" || continue
    export PATH="${PATH:+"${PATH}:"}${arg}"
  done
}

pathprepend() {
  local arg
  for arg in "$@"; do
    _pathclean "${arg}"
    test -d "${arg}" || continue
    export PATH="${arg}${PATH:+":${PATH}"}"
  done
}

# navigate up the file hierarchy (Thanks to Derek Taylor (Distrotube))
up() {
    local d=""
    local limit="$1"

    if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
        limit=1
    fi

    for ((i=1; i<=limit; i++)); do
        d="../$d"
    done

    if ! cd "$d"; then
        echo "Couldn't go up $limit dirs."
    fi
}

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

if [ -r "${HOME}"/.bash.d/tools/qwe.bash ]; then
    source "${HOME}"/.bash.d/tools/qwe.bash
else
    printf "Could not source qwe.bash."
fi

pathappend "${HOME}/scripts/general"

# file permissions: rwxr-xr-x
umask 022

# if bash is interactive shell ... bind ... and allow Ctrl-S to search forward through history by deactivating XON/XOFF (in KDE Konsole)
[[ $- = *i* ]] && bind TAB:menu-complete && stty -ixon

# Aktiviere Tab-Vervollständigung.
# siehe: https://superuser.com/questions/59175/is-there-a-way-to-make-bash-more-tab-friendly
# Mit Shift+Tab einen Eintrag in der Tab-Vervollständigung zurück gehen.
bind '"\e[Z":menu-complete-backward'

# Netter Trick ...
#     sudo ls -l | sudo dd of=/prod/test.txt
# ... falls man nicht in eine Datei umleiten darf
# (also "sudo ls -l > test.txt" ist nicht erlaubt)
# kann man es so dennoch erreichen.
# Siehe: https://stackoverflow.com/a/8213307

# Uncomment next line to enable the builtin emacs(1) command line editor
# in sh(1), e.g. C-a -> beginning-of-line.
# set -o emacs

shopt -s globstar

# ---------------------------   History  ---------------------------------------

export HISTCONTROL=ignoreboth
export HISTFILESIZE=10000
export HISTSIZE=5000
export HISTIGNORE="ls:ll:history*"
shopt -s histappend

# ---------------------------   Variables   ------------------------------------

export EDITOR=vim
export PAGER=less
export SVN_EDITOR=vim

# maybe add: --no-init
export LESS='--ignore-case --RAW-CONTROL-CHARS --quit-if-one-screen --jump-target=.5'
export SCRIPTS=${HOME}/scripts/general/

# ---------------------------   Aliases   --------------------------------------
alias h='fc -l'
alias j=jobs
# m: Enthält dann z.B. 'more' (statt less) als Pager.
alias m='$PAGER'

alias c='clear'
alias cd..='cd ..'
alias gbi='gmake && gmake install' # (gmake) (b)uild and (i)nstall
alias gmc='gmake clean' # gc should not be use because of it being the gnu-compiler
alias gst='git status'
alias vimeod='vim -S ~/vimsessions/eod-session.vim' # start vim with eod-session (end of day).
alias vi='vim'
alias grep='grep --color=auto --extended-regexp'
alias pcregrep='pcregrep --color=auto'
alias gitgrep='git grep --color=auto --no-index --extended-regexp --all-match'
alias perl6r='rlwrap perl6'
alias dirsize="find . -type d -name '[!.]*' -exec du -sh {} +"
alias rlwrap='rlwrap '
alias rm='rm -Iv '

# The space at the end is necessary for it to work!
alias sudo='sudo '
alias show-bindings="bind -p | grep -v '^#\|self-insert\|^$'"

# c = configure ... bash, etc.
alias cbash='vim ~/.bashrc'
alias cvim='vim ~/.vimrc'

# perl awk - see .inputrc for »shell-expand-line« binding (default emacs mode: C-M-e)
# -F implies -a autospit,  -n loop around
alias pawk='perl -lF'"\'"'/ /'"\'"' -E '"\'"'print \$F[0]'"\'"


# ---------------------------   Prompt Definition   ----------------------------
## BEGIN prompt definition {

# Genauere Zeit vllt. über Perl: perl -MTime::HiRes=gettimeofday -MPOSIX=strftime -e '($s,$us) = gettimeofday(); printf "%d.%06d\n", $s, $us'
# \t Zeit 24 in HH:MM:SS
# \u User
# \h Hostname
# \w the current working  directory
# Verwende "\$(my_function)" im Prompt-String um einen Funktionsaufruf für jeden neuen Prompt-String zu tätigen.
# \# command number of this command

_ttyInfo=$(tty)
_ttyInfo=${_ttyInfo##*dev/}
#BASE_PROMPT="\u@\h:(tty:${_ttyInfo}):\wSHELL_LEVEL \t:\#"
#BASE_PROMPT="\u@\h:(`tty | sed 's/\/dev\///'`):\wSHELL_LEVEL \t:\#"
BASE_PROMPT="\u@\h:(`tty | sed 's,/dev/,,'`):[\w]SHELL_LEVEL \t (cn:\#)"
#BASE_PROMPT="\u@\h:(${_ttyInfo}):\wSHELL_LEVEL \t:\#"

#PROMPT_COMMAND=

# Promp Definition 
if [ "x$SHLVL" = "x1" ]; then
    # replace SHELL_LEVEL with nothing
    BASE_PROMPT="${BASE_PROMPT/SHELL_LEVEL/}"
else
    # replace SHELL_LEVEL with variable value in parentheses
    BASE_PROMPT="${BASE_PROMPT/SHELL_LEVEL/($SHLVL)}"
fi
# PSP Prompt String Part
# see: https://unix.stackexchange.com/a/105974
color_green="\[\e[1;32m\]"
no_color="\[\e[00m\]"

PS1="${color_green}${BASE_PROMPT}\n\$${no_color} "

PS2="\u@\h \w \! ++ "
## . END prompt definition }

#-------------------------------------------------------------------------------

set -o vi

#-------------------------------------------------------------------------------

pathappend \
    ~/scripts/* \
    /usr/local/go/bin

bash_config_dir="${HOME}/.config/bash"
if test -d "${bash_config_dir}"; then
    files=$(find "${bash_config_dir}" -maxdepth 1 -regextype egrep -regex ".+\.(ba)?sh" -print)
    for file in ${files}; do 
        . "${file}"
    done
fi
unset bash_config_dir files file

function fcd() {
    local _first_matching_directory
    _first_matching_directory=$( find -E . -type d -regex "$@" 2>/dev/null | head -n 1 )
    if [ -d "${_first_matching_directory}" ]; then
        cd "${_first_matching_directory}" || return
    fi
}

#-------------------------------------------------------------------------------

if [ -f ~/work.bashrc ]; then
    . ~/work.bashrc
fi
